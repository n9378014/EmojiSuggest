{"ast":null,"code":"\"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self && self;\n\nvar t = function (t, n) {\n  return t(n = {\n    exports: {}\n  }, n.exports), n.exports;\n}(function (t, n) {\n  /*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n  t.exports = function () {\n    var t = {},\n        n = \"Array Object String Date RegExp Function Boolean Number Null Undefined\".split(\" \");\n\n    function r() {\n      return Object.prototype.toString.call(this).slice(8, -1);\n    }\n\n    for (var e = n.length; e--;) t[\"is\" + n[e]] = function (t) {\n      return function (n) {\n        return r.call(n) === t;\n      };\n    }(n[e]);\n\n    return t;\n  }();\n}),\n    n = t.isObject,\n    r = t.isNumber,\n    e = t.isArray,\n    i = t.isString;\n\nfunction s(t, n) {\n  return n + t * (1 & n) >> 1;\n}\n\nfunction o(t, n) {\n  return (t % n + n) % n;\n}\n\nfunction u(t, n) {\n  if (!/^(N|S)?(E|W)?$/i.test(t)) throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);\n  if (n = n.toLowerCase(), t = t.toUpperCase(), \"pointy\" === n && [\"N\", \"S\"].includes(t)) throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);\n  if (\"flat\" === n && [\"E\", \"W\"].includes(t)) throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);\n  return {\n    pointy: {\n      E: 0,\n      SE: 1,\n      SW: 2,\n      W: 3,\n      NW: 4,\n      NE: 5\n    },\n    flat: {\n      SE: 0,\n      S: 1,\n      SW: 2,\n      NW: 3,\n      N: 4,\n      NE: 5\n    }\n  }[n][t];\n}\n\nfunction c(t, n) {\n  return r(t) || r(n) ? r(t) ? r(n) || (n = t) : t = n : t = n = 0, {\n    x: t,\n    y: n\n  };\n}\n\nconst a = [{\n  q: 1,\n  r: 0,\n  s: -1\n}, {\n  q: 0,\n  r: 1,\n  s: -1\n}, {\n  q: -1,\n  r: 1,\n  s: 0\n}, {\n  q: -1,\n  r: 0,\n  s: 1\n}, {\n  q: 0,\n  r: -1,\n  s: 1\n}, {\n  q: 1,\n  r: -1,\n  s: 0\n}],\n      h = [{\n  q: 2,\n  r: -1,\n  s: -1\n}, {\n  q: 1,\n  r: 1,\n  s: -2\n}, {\n  q: -1,\n  r: 2,\n  s: -1\n}, {\n  q: -2,\n  r: 1,\n  s: 1\n}, {\n  q: -1,\n  r: -1,\n  s: 2\n}, {\n  q: 1,\n  r: -2,\n  s: 1\n}],\n      f = {\n  q: 1e-6,\n  r: 1e-6,\n  s: -2e-6\n};\n\nfunction l(t) {\n  return r(t) ? this[t] : this[this.indexOf(t)];\n}\n\nfunction d({\n  isValidHex: t\n}) {\n  return function (n, e) {\n    if (!t(e)) return this;\n    const i = r(n) ? n : this.indexOf(n);\n    return i < 0 ? this.push(e) : this[i] = e, this;\n  };\n}\n\nfunction x(t, n) {\n  const r = t.distance(n),\n        e = 1 / Math.max(r, 1);\n  let i = [];\n\n  for (let s = 0; s <= r; s++) {\n    const r = t.nudge().lerp(n.nudge(), e * s).round();\n    i.push(this.get(r));\n  }\n\n  return i;\n}\n\nfunction y({\n  isValidHex: t\n}) {\n  return function (n, r = 0, e = !0) {\n    if (!t(n)) throw new Error(`Invalid center hex: ${n}.`);\n    if (!this.get(n)) throw new Error(`Center hex with coordinates ${n} not present in grid.`);\n    let i = [];\n\n    for (let t = -r; t <= r; t++) for (let s = Math.max(-r, -t - r); s <= Math.min(r, -t + r); s++) {\n      const r = this.get(n.cubeToCartesian({\n        q: n.q + t,\n        r: n.r + s\n      }));\n      n.equals(r) && !e || i.push(r);\n    }\n\n    return i.filter(Boolean);\n  };\n}\n\nfunction p({\n  isValidHex: t,\n  signedModulo: n,\n  compassToNumberDirection: r\n}) {\n  return function (e, s = \"all\", o = !1) {\n    if (!t(e)) throw new Error(`Invalid hex: ${e}.`);\n    const u = o ? h : a;\n    return \"all\" === s && (s = [0, 1, 2, 3, 4, 5]), [].concat(s).map(t => {\n      i(t) && (t = r(t, e.orientation)), (t < 0 || t > 5) && (t = n(t, 6));\n      const {\n        q: s,\n        r: o\n      } = u[t];\n      return this.get(e.cubeToCartesian({\n        q: e.q + s,\n        r: e.r + o\n      }));\n    });\n  };\n}\n\nfunction g() {\n  if (0 === this.length) return 0;\n  const {\n    0: t,\n    length: n,\n    [n - 1]: r\n  } = this[0].isPointy() ? [...this].sort((t, n) => n.s - t.s || t.q - n.q) : [...this].sort((t, n) => t.q - n.q);\n  return r.toPoint().x - t.toPoint().x + this[0].width();\n}\n\nfunction b() {\n  if (0 === this.length) return 0;\n  const {\n    0: t,\n    length: n,\n    [n - 1]: r\n  } = this[0].isPointy() ? [...this].sort((t, n) => t.r - n.r) : [...this].sort((t, n) => n.s - t.s || t.r - n.r);\n  return r.toPoint().y - t.toPoint().y + this[0].height();\n}\n\nfunction q({\n  Hex: t\n}) {\n  return function (n, r) {\n    return t().fromPoint(n, r);\n  };\n}\n\nfunction P({\n  Grid: t,\n  Hex: n\n}) {\n  return function ({\n    width: r,\n    height: e,\n    start: i,\n    direction: s = 1,\n    onCreate: o = () => {}\n  }) {\n    i = n(i);\n    const [u, c, a] = {\n      1: [\"q\", \"r\", \"s\"],\n      3: [\"r\", \"s\", \"q\"],\n      5: [\"s\", \"q\", \"r\"]\n    }[s],\n          h = new t();\n    h.width = r, h.height = e, h.start = i, h.direction = s;\n\n    for (let t = 0; t < r; t++) for (let r = 0; r < e; r++) {\n      const e = n({\n        [u]: t + i[u],\n        [c]: r + i[c],\n        [a]: -t - r + i[a]\n      });\n      o(e, h), h.push(e);\n    }\n\n    return h;\n  };\n}\n\nfunction w({\n  Grid: t,\n  Hex: n\n}) {\n  return function ({\n    size: r,\n    start: e,\n    direction: i = 1,\n    onCreate: s = () => {}\n  }) {\n    e = n(e);\n    const o = {\n      1: {\n        rStart: () => 0,\n        rEnd: t => r - t\n      },\n      5: {\n        rStart: t => r - t,\n        rEnd: () => r + 1\n      }\n    },\n          {\n      rStart: u,\n      rEnd: c\n    } = o[i],\n          a = new t();\n    a.size = r, a.start = e, a.direction = i;\n\n    for (let t = 0; t < r; t++) for (let r = u(t); r < c(t); r++) {\n      const i = n({\n        q: t + e.q,\n        r: r + e.r,\n        s: -t - r + e.s\n      });\n      s(i, a), a.push(i);\n    }\n\n    return a;\n  };\n}\n\nfunction m({\n  Grid: t,\n  Hex: n\n}) {\n  return function ({\n    radius: r,\n    center: e,\n    onCreate: i = () => {}\n  }) {\n    e = n(e);\n    const s = new t();\n    s.radius = r, s.center = e;\n\n    for (let t = -r; t <= r; t++) {\n      const o = Math.max(-r, -t - r),\n            u = Math.min(r, -t + r);\n\n      for (let r = o; r <= u; r++) {\n        const o = n({\n          q: t + e.q,\n          r: r + e.r,\n          s: -t - r + e.s\n        });\n        i(o, s), s.push(o);\n      }\n    }\n\n    return s;\n  };\n}\n\nfunction H({\n  Grid: t,\n  Hex: n,\n  compassToNumberDirection: r,\n  signedModulo: e\n}) {\n  return function ({\n    width: o,\n    height: u,\n    start: c,\n    direction: a = n().isPointy() ? 0 : 1,\n    onCreate: h = () => {}\n  }) {\n    c = n(c), i(a) && (a = r(a, c.orientation)), (a < 0 || a > 5) && (a = e(a, 6));\n    const [f, l, d] = [[\"q\", \"r\", \"s\"], [\"r\", \"q\", \"s\"], [\"r\", \"s\", \"q\"], [\"s\", \"r\", \"q\"], [\"s\", \"q\", \"r\"], [\"q\", \"s\", \"r\"]][a],\n          [x, y] = c.isPointy() ? [o, u] : [u, o],\n          p = new t();\n    p.width = o, p.height = u, p.start = c, p.direction = a;\n\n    for (let t = 0; t < y; t++) {\n      const r = s(c.offset, t);\n\n      for (let e = -r; e < x - r; e++) {\n        const r = n({\n          [f]: e + c[f],\n          [l]: t + c[l],\n          [d]: -e - t + c[d]\n        });\n        h(r, p), p.push(r);\n      }\n    }\n\n    return p;\n  };\n}\n\nfunction O({\n  Grid: t,\n  Hex: n\n}) {\n  return function ({\n    radius: r,\n    center: e,\n    onCreate: i = () => {}\n  }) {\n    e = n(e);\n    const s = new t();\n    s.radius = r, s.center = e;\n    const {\n      q: o,\n      r: u,\n      s: c\n    } = e;\n    let h = n({\n      q: o,\n      r: u - r,\n      s: c + r\n    });\n\n    for (let t = 0; t < 6; t++) for (let e = 0; e < r; e++) {\n      i(h, s), s.push(h);\n      const {\n        q: r,\n        r: e,\n        s: o\n      } = a[t];\n      h = n({\n        q: h.q + r,\n        r: h.r + e,\n        s: h.s + o\n      });\n    }\n\n    return s;\n  };\n}\n\nfunction j({\n  Grid: t,\n  Hex: n\n}) {\n  return function ({\n    radius: r,\n    center: e,\n    onCreate: i = () => {}\n  }) {\n    e = n(e);\n    let s = new t();\n    i(e, s), s.push(e);\n\n    for (let t = 1; t <= r; t++) s = s.concat(this.ring({\n      radius: t,\n      center: e,\n      onCreate: i\n    }));\n\n    return s.radius = r, s.center = e, s;\n  };\n}\n\nfunction M({\n  Point: t\n}) {\n  return function (n, r) {\n    let e;\n    return ({\n      x: e,\n      y: r\n    } = t(n, r)), t(this.x + e, this.y + r);\n  };\n}\n\nfunction E({\n  Point: t\n}) {\n  return function (n, r) {\n    let e;\n    return ({\n      x: e,\n      y: r\n    } = t(n, r)), t(this.x - e, this.y - r);\n  };\n}\n\nfunction C({\n  Point: t\n}) {\n  return function (n, r) {\n    let e;\n    return ({\n      x: e,\n      y: r\n    } = t(n, r)), t(this.x * e, this.y * r);\n  };\n}\n\nfunction N({\n  Point: t\n}) {\n  return function (n, r) {\n    let e;\n    return ({\n      x: e,\n      y: r\n    } = t(n, r)), t(this.x / e, this.y / r);\n  };\n}\n\nfunction S({\n  ensureXY: t\n}) {\n  const i = {\n    add: M({\n      Point: s\n    }),\n    subtract: E({\n      Point: s\n    }),\n    multiply: C({\n      Point: s\n    }),\n    divide: N({\n      Point: s\n    })\n  };\n\n  function s(s, o) {\n    let u;\n    return u = r(s) ? t(s, o) : e(s) ? t(...s) : n(s) ? t(s.x, s.y) : t(0), Object.assign(Object.create(i), u);\n  }\n\n  return s;\n}\n\nconst R = S({\n  ensureXY: c\n});\n\nclass $ extends Array {\n  static isValidHex(t) {\n    return !0 === (t || {}).__isHoneycombHex;\n  }\n\n  fill() {\n    throw new TypeError(\"Grid.prototype.fill is not implemented\");\n  }\n\n  includes(t, n = 0) {\n    return !!(this.indexOf(t, n) + 1);\n  }\n\n  indexOf(t, n = 0) {\n    const {\n      length: r\n    } = this;\n    let e = Number(n);\n\n    for (t = R(t), e = Math.max(e >= 0 ? e : r + e, 0); e < r; e++) if (this[e].equals(t)) return e;\n\n    return -1;\n  }\n\n  lastIndexOf(t, n = this.length - 1) {\n    const {\n      length: r\n    } = this;\n    let e = Number(n);\n\n    for (t = R(t), e = e >= 0 ? Math.min(e, r - 1) : r + e; e >= 0; e--) if (this[e].equals(t)) return e;\n\n    return -1;\n  }\n\n  push(...t) {\n    return super.push(...t.filter($.isValidHex));\n  }\n\n  splice(t, n, ...r) {\n    return null == n ? super.splice(t) : super.splice(t, n, ...r.filter($.isValidHex));\n  }\n\n  unshift(...t) {\n    return super.unshift(...t.filter($.isValidHex));\n  }\n\n}\n\nfunction v(t, n, r) {\n  return n in t ? Object.defineProperty(t, n, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[n] = r, t;\n}\n\nfunction T(t, n) {\n  var r = Object.keys(t);\n\n  if (Object.getOwnPropertySymbols) {\n    var e = Object.getOwnPropertySymbols(t);\n    n && (e = e.filter(function (n) {\n      return Object.getOwnPropertyDescriptor(t, n).enumerable;\n    })), r.push.apply(r, e);\n  }\n\n  return r;\n}\n\nfunction G(t) {\n  for (var n = 1; n < arguments.length; n++) {\n    var r = null != arguments[n] ? arguments[n] : {};\n    n % 2 ? T(Object(r), !0).forEach(function (n) {\n      v(t, n, r[n]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : T(Object(r)).forEach(function (n) {\n      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));\n    });\n  }\n\n  return t;\n}\n\nfunction D(t, n) {\n  if (null == t) return {};\n\n  var r,\n      e,\n      i = function (t, n) {\n    if (null == t) return {};\n    var r,\n        e,\n        i = {},\n        s = Object.keys(t);\n\n    for (e = 0; e < s.length; e++) r = s[e], n.indexOf(r) >= 0 || (i[r] = t[r]);\n\n    return i;\n  }(t, n);\n\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(t);\n\n    for (e = 0; e < s.length; e++) r = s[e], n.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(t, r) && (i[r] = t[r]);\n  }\n\n  return i;\n}\n\nfunction z({\n  Hex: t\n}) {\n  return function (...n) {\n    return Object.assign(this, t(...n));\n  };\n}\n\nfunction V() {\n  return {\n    x: this.x,\n    y: this.y\n  };\n}\n\nfunction W() {\n  return {\n    q: this.q,\n    r: this.r,\n    s: this.s\n  };\n}\n\nfunction I({\n  q: t,\n  r: n\n}) {\n  let r, e;\n  return this.isPointy() ? (r = t + s(this.offset, n), e = n) : (r = t, e = n + s(this.offset, t)), {\n    x: r,\n    y: e\n  };\n}\n\nfunction X() {\n  return \"pointy\" === this.orientation.toLowerCase();\n}\n\nfunction Y() {\n  return \"flat\" === this.orientation.toLowerCase();\n}\n\nfunction B() {\n  const {\n    xRadius: t\n  } = this.size;\n  return this.isPointy() ? t * Math.sqrt(3) : 2 * t;\n}\n\nfunction _() {\n  const {\n    yRadius: t\n  } = this.size;\n  return this.isPointy() ? 2 * t : t * Math.sqrt(3);\n}\n\nfunction A({\n  Point: t\n}) {\n  return function () {\n    const n = this.width(),\n          r = this.height(),\n          {\n      x: e,\n      y: i\n    } = this.origin;\n    return this.isPointy() ? [t(n - e, .25 * r - i), t(n - e, .75 * r - i), t(.5 * n - e, r - i), t(0 - e, .75 * r - i), t(0 - e, .25 * r - i), t(.5 * n - e, 0 - i)] : [t(n - e, .5 * r - i), t(.75 * n - e, r - i), t(.25 * n - e, r - i), t(0 - e, .5 * r - i), t(.25 * n - e, 0 - i), t(.75 * n - e, 0 - i)];\n  };\n}\n\nfunction L({\n  Point: t\n}) {\n  return function () {\n    const {\n      x: n,\n      y: r\n    } = this.origin;\n    return t(this.width() / 2 - n, this.height() / 2 - r);\n  };\n}\n\nfunction k({\n  Point: t\n}) {\n  return function () {\n    const {\n      q: n,\n      r: r,\n      size: e\n    } = this,\n          {\n      xRadius: i,\n      yRadius: s\n    } = e;\n    let o, u;\n    return this.isPointy() ? (o = i * Math.sqrt(3) * (n + r / 2), u = 3 * s / 2 * r) : (o = 3 * i / 2 * n, u = s * Math.sqrt(3) * (r + n / 2)), t(o, u);\n  };\n}\n\nfunction F({\n  Point: t,\n  Hex: n\n}) {\n  return function (r, e) {\n    const {\n      xRadius: i,\n      yRadius: s\n    } = this.size;\n    let o, u, c;\n    return ({\n      x: o,\n      y: e\n    } = t(r, e).subtract(this.center())), this.isPointy() ? (u = Math.sqrt(3) * o / (3 * i) - e / (3 * s), c = 2 / 3 * (e / s)) : (u = 2 / 3 * (o / i), c = Math.sqrt(3) * e / (3 * s) - o / (3 * i)), n({\n      q: u,\n      r: c,\n      s: -u - c\n    }).round();\n  };\n}\n\nfunction U({\n  Hex: t,\n  Point: n\n}) {\n  return function (r) {\n    const {\n      x: e,\n      y: i\n    } = n(r);\n    return t(this.x + e, this.y + i, G({}, this));\n  };\n}\n\nfunction J({\n  Hex: t,\n  Point: n\n}) {\n  return function (r) {\n    const {\n      x: e,\n      y: i\n    } = n(r);\n    return t(this.x - e, this.y - i, G({}, this));\n  };\n}\n\nfunction K({\n  Point: t\n}) {\n  return function (n) {\n    if (null != n && (e(n) || r(n.x) && r(n.y))) {\n      const {\n        x: r,\n        y: e\n      } = t(n);\n      return this.x === r && this.y === e;\n    }\n\n    return !1;\n  };\n}\n\nfunction Q(t) {\n  return Math.max(Math.abs(this.q - t.q), Math.abs(this.r - t.r), Math.abs(this.s - t.s));\n}\n\nfunction Z({\n  Hex: t\n}) {\n  return function () {\n    let {\n      q: n,\n      r: r,\n      s: e\n    } = this,\n        i = Math.round(n),\n        s = Math.round(r),\n        o = Math.round(e);\n    const u = Math.abs(n - i),\n          c = Math.abs(r - s),\n          a = Math.abs(e - o);\n    return u > c && u > a ? i = -s - o : c > a ? s = -i - o : o = -i - s, t(G(G({}, this), {}, {\n      q: i,\n      r: s,\n      s: o\n    }));\n  };\n}\n\nfunction tt({\n  Hex: t\n}) {\n  return function (n, r) {\n    const e = this.q * (1 - r) + n.q * r,\n          i = this.r * (1 - r) + n.r * r;\n    return t(G(G({}, this), {}, {\n      q: e,\n      r: i,\n      s: -e - i\n    }));\n  };\n}\n\nfunction nt({\n  Hex: t\n}) {\n  return function () {\n    const {\n      q: n,\n      r: r,\n      s: e\n    } = f;\n    return t(G(G({}, this), {}, {\n      q: this.q + n,\n      r: this.r + r,\n      s: this.s + e\n    }));\n  };\n}\n\nfunction rt() {\n  return `${this.x},${this.y}`;\n}\n\nconst et = {\n  thirdCoordinate: function (t, n) {\n    return -t - n;\n  }\n};\n\nconst it = S({\n  ensureXY: c\n}),\n      st = function ({\n  ensureXY: t,\n  normalizeRadiuses: i,\n  Point: o\n}) {\n  return function (u = {}) {\n    const c = function ({\n      Point: t\n    }) {\n      return function (n, r) {\n        let e, i, o;\n        return ({\n          x: e,\n          y: r\n        } = t(n, r)), this.isPointy() ? (i = e - s(this.offset, r), o = r) : (i = e, o = r - s(this.offset, e)), {\n          q: i,\n          r: o,\n          s: -i - o\n        };\n      };\n    }({\n      Point: o\n    }),\n          a = {\n      __isHoneycombHex: !0,\n      orientation: \"pointy\",\n      origin: 0,\n      size: {\n        xRadius: 1,\n        yRadius: 1\n      },\n      offset: -1,\n\n      get q() {\n        return this.cartesianToCube(this).q;\n      },\n\n      get r() {\n        return this.cartesianToCube(this).r;\n      },\n\n      get s() {\n        return this.cartesianToCube(this).s;\n      },\n\n      add: U({\n        Hex: f,\n        Point: o\n      }),\n      cartesian: V,\n      cartesianToCube: c,\n      center: L({\n        Point: o\n      }),\n      coordinates: V,\n      corners: A({\n        Point: o\n      }),\n      cube: W,\n      cubeToCartesian: I,\n      distance: Q,\n      equals: K({\n        Point: o\n      }),\n      fromPoint: F({\n        Point: o,\n        Hex: f\n      }),\n      height: _,\n      isFlat: Y,\n      isPointy: X,\n      lerp: tt({\n        Hex: f\n      }),\n      nudge: nt({\n        Hex: f\n      }),\n      round: Z({\n        Hex: f\n      }),\n      set: z({\n        Hex: f\n      }),\n      subtract: J({\n        Hex: f,\n        Point: o\n      }),\n      toCartesian: I,\n      toCube: c,\n      toPoint: k({\n        Point: o\n      }),\n      toString: rt,\n      width: B\n    },\n          h = Object.assign(a, u);\n\n    function f(i, s, o = {}) {\n      let u;\n\n      if (n(i)) {\n        let {\n          q: t,\n          r: n,\n          s: e\n        } = i,\n            c = D(i, [\"q\", \"r\", \"s\"]);\n\n        if (r(t) || r(n) || r(e)) {\n          const r = t + n + e;\n          if (Number.isNaN(r) || r > 1e-12) throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${n}, s: ${e}, sum: ${t + n + e}.`);\n          ({\n            x: u,\n            y: s\n          } = h.cubeToCartesian({\n            q: t,\n            r: n,\n            s: e\n          }));\n        } else ({\n          x: u,\n          y: s\n        } = i);\n\n        o = c;\n      } else e(i) ? ([u, s] = i, o = {}) : u = i;\n\n      return Object.assign(Object.create(h), Object.assign(o, t(u, s)));\n    }\n\n    return h.size = i(h.size, h.isPointy()), h.origin = o(h.origin), Object.assign(f, et, {\n      toJSON: () => u\n    }), f;\n  };\n}({\n  ensureXY: c,\n  normalizeRadiuses: function (t, e) {\n    if (n(t)) {\n      if (r(t.xRadius) && r(t.yRadius)) return t;\n      const {\n        width: n,\n        height: i\n      } = t;\n      if (r(n) && r(i)) return e ? {\n        xRadius: n / Math.sqrt(3),\n        yRadius: i / 2\n      } : {\n        xRadius: n / 2,\n        yRadius: i / Math.sqrt(3)\n      };\n    }\n\n    if (r(t)) return {\n      xRadius: t,\n      yRadius: t\n    };\n    throw new Error(`Invalid size: ${t}. Set it as a number or as an object containing width and height.`);\n  },\n  Point: it\n}),\n      ot = function ({\n  extendHex: t,\n  Grid: n,\n  Point: i\n}) {\n  const {\n    isValidHex: s\n  } = n;\n  return function (c = t()) {\n    function a(...t) {\n      return t = t.filter(Boolean), e(t[0]) && (0 === t[0].length || t[0].some(t => !r(t))) && (t = t[0]), new n(...t.map(t => c(t)));\n    }\n\n    return Object.assign(a, {\n      Hex: c,\n      isValidHex: s,\n      pointToHex: q({\n        Point: i,\n        Hex: c\n      }),\n      parallelogram: P({\n        Grid: n,\n        Hex: c\n      }),\n      triangle: w({\n        Grid: n,\n        Hex: c\n      }),\n      hexagon: m({\n        Grid: n,\n        Hex: c\n      }),\n      rectangle: H({\n        Grid: n,\n        Hex: c,\n        compassToNumberDirection: u,\n        signedModulo: o\n      }),\n      ring: O({\n        Grid: n,\n        Hex: c\n      }),\n      spiral: j({\n        Grid: n,\n        Hex: c\n      })\n    }), Object.assign(n.prototype, {\n      get: l,\n      hexesBetween: x,\n      hexesInRange: y({\n        isValidHex: s\n      }),\n      neighborsOf: p({\n        isValidHex: s,\n        signedModulo: o,\n        compassToNumberDirection: u\n      }),\n      pointHeight: b,\n      pointWidth: g,\n      set: d({\n        isValidHex: s\n      })\n    }), a;\n  };\n}({\n  extendHex: st,\n  Grid: $,\n  Point: it\n});\n\nexport { it as Point, ot as defineGrid, st as extendHex };","map":{"version":3,"sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/constants.js","../src/grid/prototype.js","../src/grid/statics.js","../src/point/prototype.js","../src/point/index.js","../src/grid/class.js","../src/hex/prototype.js","../src/hex/index.js","../src/hex/statics.js","../src/honeycomb.js","../src/grid/index.js"],"names":["module","factory","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","pointy","E","SE","SW","W","NW","NE","flat","S","N","ensureXY","x","y","isNumber","size","isPointy","isObject","xRadius","yRadius","width","height","Math","sqrt","DIRECTION_COORDINATES","q","r","s","DIAGONAL_DIRECTION_COORDINATES","EPSILON","get","keyOrPoint","indexOf","setFactory","isValidHex","newHex","index","push","hexesBetween","firstHex","lastHex","step","max","hexes","hex","nudge","lerp","round","hexesInRangeFactory","centerHex","range","includeCenterHex","min","cubeToCartesian","equals","filter","Boolean","neighborsOfFactory","directions","diagonal","coordinates","concat","map","direction","isString","pointWidth","mostLeft","mostRight","sort","a","b","toPoint","pointHeight","mostUp","mostDown","pointToHexFactory","Hex","pointOrX","fromPoint","parallelogramFactory","Grid","start","onCreate","firstCoordinate","secondCoordinate","thirdCoordinate","grid","first","second","triangleFactory","DIRECTIONS","rStart","rEnd","hexagonFactory","radius","center","startR","endR","rectangleFactory","firstStop","secondStop","secondOffset","ringFactory","j","spiralFactory","ring","addFactory","Point","subtractFactory","multiplyFactory","divideFactory","PointFactory","add","methods","subtract","multiply","divide","isArray","assign","create","Array","__isHoneycombHex","fill","TypeError","point","fromIndex","Number","lastIndexOf","super","splice","deleteCount","unshift","args","cube","isFlat","cornersFactory","origin","centerFactory","toPointFactory","fromPointFactory","equalsFactory","abs","roundFactory","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","lerpFactory","t","nudgeFactory","staticMethods","normalizeRadiuses","cartesianToCube","defaultPrototype","cartesian","corners","set","toCartesian","toCube","finalPrototype","toJSON","xOrProps","customProps","rest","sum","isNaN","extendHex","extendHexFactory","defineGrid","defineGridFactory","GridFactory","pointToHex","statics","parallelogram","triangle","hexagon","rectangle","spiral","hexesInRange","neighborsOf","points","some"],"mappings":"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","sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber, isObject } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n  return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n  return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n  if (!/^(N|S)?(E|W)?$/i.test(value)) {\n    throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n  }\n\n  orientation = orientation.toLowerCase()\n  value = value.toUpperCase()\n\n  if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n  }\n  if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n  }\n\n  /**\n   * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n   * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n   * and flat hexes don't have a west and east compass direction.\n   *\n   * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n   * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n   *\n   * @typedef {string} COMPASS_DIRECTION\n   *\n   * @readonly\n   * @enum {COMPASS_DIRECTION}\n   *\n   * @property {COMPASS_DIRECTION} E   east\n   * @property {COMPASS_DIRECTION} SE  southeast\n   * @property {COMPASS_DIRECTION} S   south\n   * @property {COMPASS_DIRECTION} SW  southwest\n   * @property {COMPASS_DIRECTION} W   west\n   * @property {COMPASS_DIRECTION} NW  northwest\n   * @property {COMPASS_DIRECTION} N   north\n   * @property {COMPASS_DIRECTION} NE  northeast\n   */\n  return {\n    pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n    flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 },\n  }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n  if (!isNumber(x) && !isNumber(y)) {\n    x = y = 0\n  } else if (!isNumber(x)) {\n    x = y\n  } else if (!isNumber(y)) {\n    y = x\n  }\n\n  return { x, y }\n}\n\nexport function normalizeRadiuses(size, isPointy) {\n  if (isObject(size)) {\n    if (isNumber(size.xRadius) && isNumber(size.yRadius)) {\n      return size\n    }\n\n    const { width, height } = size\n    if (isNumber(width) && isNumber(height)) {\n      return isPointy\n        ? { xRadius: width / Math.sqrt(3), yRadius: height / 2 }\n        : { xRadius: width / 2, yRadius: height / Math.sqrt(3) }\n    }\n  }\n\n  if (isNumber(size)) {\n    return { xRadius: size, yRadius: size }\n  }\n\n  throw new Error(`Invalid size: ${size}. Set it as a number or as an object containing width and height.`)\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n  { q: 1, r: 0, s: -1 },\n  { q: 0, r: 1, s: -1 },\n  { q: -1, r: 1, s: 0 },\n  { q: -1, r: 0, s: 1 },\n  { q: 0, r: -1, s: 1 },\n  { q: 1, r: -1, s: 0 },\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n  { q: 2, r: -1, s: -1 },\n  { q: 1, r: 1, s: -2 },\n  { q: -1, r: 2, s: -1 },\n  { q: -2, r: 1, s: 1 },\n  { q: -1, r: -1, s: 2 },\n  { q: 1, r: -2, s: 1 },\n]\n\nexport const EPSILON = { q: 1e-6, r: 1e-6, s: -2e-6 }\n","import { isNumber, isString } from 'axis.js'\nimport { DIAGONAL_DIRECTION_COORDINATES, DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n  if (isNumber(keyOrPoint)) {\n    return this[keyOrPoint]\n  } else {\n    return this[this.indexOf(keyOrPoint)]\n  }\n}\n\nexport function setFactory({ isValidHex }) {\n  /**\n   * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n   *\n   * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n   * If the new hex is invalid, nothing changes.\n   *\n   * @memberof Grid#\n   * @instance\n   *\n   * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n   * @param {hex} newHex                  The replacing hex.\n   *\n   * @returns {grid}                      Itself.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n   *\n   * // replace a hex:\n   * grid.set(0, Hex(1, 1))\n   * grid                         // [ { x: 1, y: 1 } ]\n   * // the target hex can also be a point:\n   * grid.set([1, 1], Hex(2, 2))\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // invalid replace values are ignored:\n   * grid.set(0, 'invalid')\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // when the target hex isn't present in the grid, the replacing hex is added instead:\n   * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n   * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n   */\n  return function set(keyOrPoint, newHex) {\n    if (!isValidHex(newHex)) {\n      return this\n    }\n\n    const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n    if (index < 0) {\n      this.push(newHex)\n    } else {\n      this[index] = newHex\n    }\n\n    return this\n  }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n  const distance = firstHex.distance(lastHex)\n  const step = 1.0 / Math.max(distance, 1)\n  let hexes = []\n\n  for (let i = 0; i <= distance; i++) {\n    const hex = firstHex\n      .nudge()\n      .lerp(lastHex.nudge(), step * i)\n      .round()\n    hexes.push(this.get(hex))\n  }\n\n  return hexes\n}\n\nexport function hexesInRangeFactory({ isValidHex }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#range-coordinate|redblobgames.com}\n   *\n   * @param {hex} centerHex                   A hex to get surrounding hexes from.\n   * @param {number} [range=0]                The range (in hexes) surrounding the center hex.\n   * @param {boolean} [includeCenterHex=true] Whether to include the center hex in the result\n   *\n   * @returns {hex[]}             An array with all hexes surrounding the passed center hex.\n   *                              Only hexes that are present in the grid are returned.\n   *\n   * @throws {Error} When no valid hex is passed.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const grid = Grid.rectangle({ width: 5, height: 5 })\n   *\n   * grid.hexesInRange(Hex(2, 2), 2)          // [\n   *                                          //    { x: 0, y: 2 },\n   *                                          //    { x: 0, y: 3 },\n   *                                          //    { x: 1, y: 4 },\n   *                                          //    ...\n   *                                          //    { x: 3, y: 0 },\n   *                                          //    { x: 3, y: 1 },\n   *                                          //    { x: 4, y: 2 }\n   *                                          // ]\n   *\n   * // only returns hexes that exist in the grid:\n   * grid.hexesInRange(Hex(0, 0), 1)          // [\n   *                                          //    { x: 0, y: 0 },\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: 1, y: 0 }\n   *                                          // ]\n   *\n   * // exclude center hex:\n   * grid.hexesInRange(Hex(2, 2), 1, false)   // [\n   *                                          //    { x: 1, y: 2 },\n   *                                          //    { x: 1, y: 3 },\n   *                                          //    { x: 1, y: 1 },\n   *                                          //    { x: 2, y: 3 },\n   *                                          //    { x: 3, y: 2 }\n   *                                          // ]\n   */\n  return function hexesInRange(centerHex, range = 0, includeCenterHex = true) {\n    if (!isValidHex(centerHex)) {\n      throw new Error(`Invalid center hex: ${centerHex}.`)\n    }\n\n    if (!this.get(centerHex)) {\n      throw new Error(`Center hex with coordinates ${centerHex} not present in grid.`)\n    }\n\n    let hexes = []\n\n    for (let q = -range; q <= range; q++) {\n      for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {\n        const hex = this.get(centerHex.cubeToCartesian({ q: centerHex.q + q, r: centerHex.r + r }))\n\n        if (centerHex.equals(hex) && !includeCenterHex) {\n          continue\n        }\n\n        hexes.push(hex)\n      }\n    }\n\n    return hexes.filter(Boolean)\n  }\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n   *\n   * @param {hex} hex\n   * A hex to get 1 or more neighbors from.\n   * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n   * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n   * @param {boolean} [diagonal=false]\n   * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n   *\n   * @returns {hex[]}\n   * An array with the neighboring hex for each queried direction or `undefined` if the hex doesn't exist in the grid.\n   *\n   * @throws {Error} When no valid hex is passed.\n   * @throws {Error} When the direction is invalid for the hex.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n   * const grid = Grid.hexagon({ radius: 1 })\n   *\n   * // all neighbors:\n   * grid.neighborsOf(Hex())          // [\n   *                                  //    { x: 1, y: 0 },\n   *                                  //    { x: 0, y: 1 },\n   *                                  //    { x: -1, y: 1 },\n   *                                  //    { x: -1, y: 0 },\n   *                                  //    { x: -1, y: -1 },\n   *                                  //    { x: 0, y: -1 },\n   *                                  // ]\n   * // specific neighbor:\n   * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n   * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n   *\n   * // multiple neighbors:\n   * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   *\n   * grid.neighborsOf(Hex(), [1, 2])          // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   * // diagonal neighbor:\n   * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n   *\n   * // returns undefined for hexes that aren't present in the grid:\n   * grid.neighborsOf(Hex(-1, -1), 'NW')      // [undefined]\n   */\n  return function neighborsOf(hex, directions = 'all', diagonal = false) {\n    if (!isValidHex(hex)) {\n      throw new Error(`Invalid hex: ${hex}.`)\n    }\n\n    const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n    if (directions === 'all') {\n      directions = [0, 1, 2, 3, 4, 5]\n    }\n\n    return (directions = []\n      // ensure directions is an array\n      .concat(directions)\n      .map((direction) => {\n        // todo: move this to a util, also grid/statics.js#277\n        if (isString(direction)) {\n          direction = compassToNumberDirection(direction, hex.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n          direction = signedModulo(direction, 6)\n        }\n\n        const { q, r } = coordinates[direction]\n        return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n      }))\n  }\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The width of the grid in points/pixels.\n */\nexport function pointWidth() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from left to right and take the first and last\n  const { 0: mostLeft, length, [length - 1]: mostRight } = this[0].isPointy()\n    ? [...this].sort((a, b) => b.s - a.s || a.q - b.q)\n    : [...this].sort((a, b) => a.q - b.q)\n\n  return mostRight.toPoint().x - mostLeft.toPoint().x + this[0].width()\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The heigth of the grid in points/pixels.\n */\nexport function pointHeight() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from top to bottom and take the first and last\n  const { 0: mostUp, length, [length - 1]: mostDown } = this[0].isPointy()\n    ? [...this].sort((a, b) => a.r - b.r)\n    : [...this].sort((a, b) => b.s - a.s || a.r - b.r)\n\n  return mostDown.toPoint().y - mostUp.toPoint().y + this[0].height()\n}\n","import { isString } from 'axis.js'\nimport { DIRECTION_COORDINATES } from '../hex/constants'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n  /**\n   * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link Hex#fromPoint}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const Point = Honeycomb.Point\n   *\n   * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n   * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n   * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function pointToHex(pointOrX, y) {\n    return Hex().fromPoint(pointOrX, y)\n  }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n   */\n  return function parallelogram({\n    width,\n    height,\n    start,\n    direction = 1,\n    /**\n     * Callback of a {@link Grid} shape method.\n     * Gets called for each hex that's about to be added to the grid.\n     *\n     * @callback onCreate\n     * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n     * @param {grid} grid   The grid (for as far as it's created).\n     * @returns {void}      Nothing.\n     */\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: ['q', 'r', 's'],\n      3: ['r', 's', 'q'],\n      5: ['s', 'q', 'r'],\n    }\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let first = 0; first < width; first++) {\n      for (let second = 0; second < height; second++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.size                 The side length (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n   * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a triangle arrangement.\n   */\n  return function triangle({ size, start, direction = 1, onCreate = () => {} }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: {\n        rStart: () => 0,\n        rEnd: (q) => size - q,\n      },\n      5: {\n        rStart: (q) => size - q,\n        rEnd: () => size + 1,\n      },\n    }\n    const { rStart, rEnd } = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.size = size\n    grid.start = start\n    grid.direction = direction\n\n    for (let q = 0; q < size; q++) {\n      for (let r = rStart(q); r < rEnd(q); r++) {\n        const hex = Hex({\n          q: q + start.q,\n          r: r + start.r,\n          s: -q - r + start.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n   */\n  return function hexagon({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    for (let q = -radius; q <= radius; q++) {\n      const startR = Math.max(-radius, -q - radius)\n      const endR = Math.min(radius, -q + radius)\n\n      for (let r = startR; r <= endR; r++) {\n        const hex = Hex({\n          q: q + center.q,\n          r: r + center.r,\n          s: -q - r + center.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n  /**\n   * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n   * The direction (from the start hex) in which to create the shape.\n   * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n   * Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n   */\n  return function rectangle({\n    width,\n    height,\n    start,\n    direction = Hex().isPointy() ? 0 : 1, // E or S\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n\n    if (isString(direction)) {\n      direction = compassToNumberDirection(direction, start.orientation)\n    }\n\n    if (direction < 0 || direction > 5) {\n      direction = signedModulo(direction, 6)\n    }\n\n    const DIRECTIONS = [\n      ['q', 'r', 's'],\n      ['r', 'q', 's'],\n      ['r', 's', 'q'],\n      ['s', 'r', 'q'],\n      ['s', 'q', 'r'],\n      ['q', 's', 'r'],\n    ]\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let second = 0; second < secondStop; second++) {\n      const secondOffset = offsetFromZero(start.offset, second)\n\n      for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function ringFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a ring.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a ring arrangement.\n   */\n  return function ring({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    const { q, r, s } = center\n    let hex = Hex({ q, r: r - radius, s: s + radius })\n\n    for (let i = 0; i < 6; i++) {\n      for (let j = 0; j < radius; j++) {\n        onCreate(hex, grid)\n        grid.push(hex)\n\n        const { q, r, s } = DIRECTION_COORDINATES[i]\n        hex = Hex({ q: hex.q + q, r: hex.r + r, s: hex.s + s })\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function spiralFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a spiral starting from the center outward.\n   * The result is the same as a hexagon, but the order of hexes is different.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings-spiral|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a spiral arrangement.\n   */\n  return function spiral({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    let grid = new Grid()\n\n    onCreate(center, grid)\n    grid.push(center)\n\n    for (let i = 1; i <= radius; i++) {\n      grid = grid.concat(this.ring({ radius: i, center, onCreate }))\n    }\n\n    grid.radius = radius\n    grid.center = center\n\n    return grid\n  }\n}\n","export function addFactory({ Point }) {\n  /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n  return function add(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x + x, this.y + y)\n  }\n}\n\nexport function subtractFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The difference between the passed point's coordinates and the current point's.\n   */\n  return function subtract(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x - x, this.y - y)\n  }\n}\n\nexport function multiplyFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n   */\n  return function multiply(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x * x, this.y * y)\n  }\n}\n\nexport function divideFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The division of the current point's coordinates and the passed point's.\n   */\n  return function divide(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x / x, this.y / y)\n  }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n  const prototype = {\n    add: methods.addFactory({ Point }),\n    subtract: methods.subtractFactory({ Point }),\n    multiply: methods.multiplyFactory({ Point }),\n    divide: methods.divideFactory({ Point }),\n  }\n\n  /**\n   * Factory function for creating two-dimensional points.\n   *\n   * @function Point\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}                             A point.\n   *\n   * @example\n   * const Point = Honeycomb.Point\n   *\n   * Point()                  // { x: 0, y: 0 }\n   * Point(1)                 // { x: 1, y: 1 }\n   * Point(1, 2)              // { x: 1, y: 2 }\n   *\n   * Point([])                // { x: 0, y: 0 }\n   * Point([1])               // { x: 1, y: 1 }\n   * Point([1, 2])            // { x: 1, y: 2 }\n   *\n   * Point({})                // { x: 0, y: 0 }\n   * Point({ x: 1 })          // { x: 1, y: 1 }\n   * Point({ y: 2 })          // { x: 2, y: 2 }\n   * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n   */\n  function Point(pointOrX, y) {\n    let coordinates\n    /**\n     * An object with just an `x` and a `y` property.\n     *\n     * Create your own:\n     * ```javascript\n     * const point = { x: 1, y: 2 }\n     * ```\n     *\n     * Or use the included {@link Point} factory:\n     * ```javascript\n     * const point = Honeycomb.Point(1, 2)\n     * ```\n     *\n     * @typedef {Object} point\n     * @property {number} x (horizontal) x coordinate\n     * @property {number} y (vertical) y coordinate\n     */\n\n    if (isNumber(pointOrX)) {\n      coordinates = ensureXY(pointOrX, y)\n    } else if (isArray(pointOrX)) {\n      coordinates = ensureXY(...pointOrX)\n    } else if (isObject(pointOrX)) {\n      coordinates = ensureXY(pointOrX.x, pointOrX.y)\n    } else {\n      coordinates = ensureXY(0)\n    }\n\n    return Object.assign(Object.create(prototype), coordinates)\n  }\n\n  return Point\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n  /**\n   * @private\n   * @param {*} value     Any value.\n   * @returns {boolean}   Whether the passed value is a valid hex.\n   */\n  static isValidHex(value) {\n    return (value || {}).__isHoneycombHex === true\n  }\n\n  /**\n   * @memberof Grid#\n   * @override\n   * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n   *\n   * @returns {TypeError} An error.\n   */\n  fill() {\n    throw new TypeError('Grid.prototype.fill is not implemented')\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n   * but searches the passed hex (which can also be a {@link point}.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *\n   * @returns {boolean}               Whether the hex is included in the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n   *\n   * grid.includes(Hex(0))        // true\n   * grid.includes([0, 0])        // true\n   * grid.includes(Hex(0), 1)     // false\n   * grid.includes(Hex(5, 7))     // false\n   */\n  includes(point, fromIndex = 0) {\n    return !!(this.indexOf(point, fromIndex) + 1)\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *                                  If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.indexOf(Hex(0))     // 0\n   * grid.indexOf([0, 0])     // 0\n   * grid.indexOf(Hex(0), 1)  // 2\n   * grid.indexOf(Hex(5, 7))  // -1\n   */\n  indexOf(point, fromIndex = 0) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = Math.max(i >= 0 ? i : length + i, 0)\n\n    for (i; i < length; i++) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n   * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point                 The coordinates to search for.\n   * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n   *                                      If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.lastIndexOf(Hex(0))     // 2\n   * grid.lastIndexOf([0, 0])     // 2\n   * grid.lastIndexOf(Hex(0), 1)  // 0\n   * grid.lastIndexOf(Hex(5, 7))  // -1\n   */\n  lastIndexOf(point, fromIndex = this.length - 1) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n    for (i; i >= 0; i--) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.push(Hex(1))            // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.push('invalid')         // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   */\n  push(...hexes) {\n    return super.push(...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {number} start                        Index at which to start changing the grid.\n   * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n   * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n   *\n   * @returns {hex[]}                             A grid with the deleted hexes (if any).\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid.rectangle({ width: 2, height: 1 })\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 0, y: 1 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   *\n   * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n   *\n   * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n   * grid\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 2, y: 2 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   */\n  splice(start, deleteCount, ...hexes) {\n    // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n    // this is not according to spec: it should delete all hexes (starting from `start`)\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n    if (deleteCount == null) {\n      return super.splice(start)\n    }\n\n    return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.unshift(Hex(1))         // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   *\n   * grid.unshift('invalid')      // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   */\n  unshift(...hexes) {\n    return super.unshift(...hexes.filter(Grid.isValidHex))\n  }\n}\n","import { isArray, isNumber } from 'axis.js'\nimport { offsetFromZero } from '../utils'\nimport { EPSILON } from './constants'\n\nexport function setFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n   * @returns {hex}           Itself with the passed parameters merged into it.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   *\n   * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n   * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n   * hex === updatedHex                                   // true: hex is updated in-place\n   */\n  return function set(...args) {\n    return Object.assign(this, Hex(...args))\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n  return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n  return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n  let x, y\n\n  if (this.isPointy()) {\n    x = q + offsetFromZero(this.offset, r)\n    y = r\n  } else {\n    x = q\n    y = r + offsetFromZero(this.offset, q)\n  }\n\n  return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   *\n   * @todo make this a static (and instance?) method\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * const Point = Honeycomb.Point\n   *\n   * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n   */\n  return function cartesianToCube(pointOrX, y) {\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y))\n\n    if (this.isPointy()) {\n      q = x - offsetFromZero(this.offset, y)\n      r = y\n    } else {\n      q = x\n      r = y - offsetFromZero(this.offset, x)\n    }\n\n    return { q, r, s: -q - r }\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy  orientation.\n */\nexport function isPointy() {\n  return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat  orientation.\n */\nexport function isFlat() {\n  return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n  const { xRadius } = this.size\n  return this.isPointy() ? xRadius * Math.sqrt(3) : xRadius * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n  const { yRadius } = this.size\n  return this.isPointy() ? yRadius * 2 : yRadius * Math.sqrt(3)\n}\n\nexport function cornersFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point[]}\n   * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n   * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n   *\n   * @example\n   * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n   * const Hex1 = Honeycomb.extendHex({ size: 30 })\n   * Hex1().corners() // [\n   *                  //    { x: 51.96152422706631, y: 15 },\n   *                  //    { x: 51.96152422706631, y: 45 },\n   *                  //    { x: 25.980762113533157, y: 60 },\n   *                  //    { x: 0, y: 45 },\n   *                  //    { x: 0, y: 15 },\n   *                  //    { x: 25.980762113533157, y: 0 }\n   *                  // ]\n   *\n   * // set the origin to a hex's center\n   * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n   * Hex2().corners() // [\n   *                  //    { x: 25.980762113533157, y: -15 },\n   *                  //    { x: 25.980762113533157, y: 15 },\n   *                  //    { x: 0, y: 30 },\n   *                  //    { x: -25.980762113533157, y: 15 },\n   *                  //    { x: -25.980762113533157, y: -15 },\n   *                  //    { x: 0, y: -30 }\n   *                  // ]\n   */\n  return function corners() {\n    const width = this.width()\n    const height = this.height()\n    const { x, y } = this.origin\n\n    if (this.isPointy()) {\n      return [\n        Point(width - x, height * 0.25 - y),\n        Point(width - x, height * 0.75 - y),\n        Point(width * 0.5 - x, height - y),\n        Point(0 - x, height * 0.75 - y),\n        Point(0 - x, height * 0.25 - y),\n        Point(width * 0.5 - x, 0 - y),\n      ]\n    } else {\n      return [\n        Point(width - x, height * 0.5 - y),\n        Point(width * 0.75 - x, height - y),\n        Point(width * 0.25 - x, height - y),\n        Point(0 - x, height * 0.5 - y),\n        Point(width * 0.25 - x, 0 - y),\n        Point(width * 0.75 - x, 0 - y),\n      ]\n    }\n  }\n}\n\nexport function centerFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n   * Note that the default origin is the top left corner, so the default center is\n   * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n   *\n   * @example\n   * const Hex1 = Honeycomb.extendHex({ size: 10 })\n   * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n   *\n   * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n   * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n   */\n  return function center() {\n    const { x, y } = this.origin\n    return Point(this.width() / 2 - x, this.height() / 2 - y)\n  }\n}\n\nexport function toPointFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} The hex's origin point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 30 })\n   * Hex().toPoint()          // { x: 0, y: 0 }\n   * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n   */\n  return function toPoint() {\n    const { q, r, size } = this\n    const { xRadius, yRadius } = size\n    let x, y\n\n    if (this.isPointy()) {\n      x = xRadius * Math.sqrt(3) * (q + r / 2)\n      y = ((yRadius * 3) / 2) * r\n    } else {\n      x = ((xRadius * 3) / 2) * q\n      y = yRadius * Math.sqrt(3) * (r + q / 2)\n    }\n\n    return Point(x, y)\n  }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n  /**\n   * Returns a hex from the passed {@link point}.\n   *\n   * @memberof Hex\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Point = Honeycomb.Point\n   * const hex = Hex()\n   *\n   * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n   * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n   * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function fromPoint(pointOrX, y) {\n    const { xRadius, yRadius } = this.size\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n    // inspired by https://github.com/gojuno/hexgrid-py\n    // and simplified by https://www.symbolab.com/solver/simplify-calculator/simplify\n    if (this.isPointy()) {\n      q = (Math.sqrt(3) * x) / (3 * xRadius) - y / (3 * yRadius)\n      r = (2 / 3) * (y / yRadius)\n    } else {\n      q = (2 / 3) * (x / xRadius)\n      r = (Math.sqrt(3) * y) / (3 * yRadius) - x / (3 * xRadius)\n    }\n\n    return Hex({ q, r, s: -q - r }).round()\n  }\n}\n\nexport function addFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to add.\n   *\n   * @param {point} point The hex (or point) that will be added to the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n   *                      Any custom properties are copied.\n   */\n  return function add(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x + x, this.y + y, { ...this })\n  }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to subtract.\n   *\n   * @param {point} point The hex (or point) that will be subtracted from the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n   *                      Any custom properties are copied.\n   */\n  return function subtract(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x - x, this.y - y, { ...this })\n  }\n}\n\nexport function equalsFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n   * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n   */\n  return function equals(point) {\n    if (point != null && (isArray(point) || (isNumber(point.x) && isNumber(point.y)))) {\n      const { x, y } = Point(point)\n      return this.x === x && this.y === y\n    }\n\n    return false\n  }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n  return Math.max(Math.abs(this.q - hex.q), Math.abs(this.r - hex.r), Math.abs(this.s - hex.s))\n}\n\nexport function roundFactory({ Hex }) {\n  /**\n   * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n   *\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with rounded coordinates.\n   *                  Any custom properties are copied.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n   */\n  return function round() {\n    let { q, r, s } = this\n    let roundedQ = Math.round(q)\n    let roundedR = Math.round(r)\n    let roundedS = Math.round(s)\n    const diffQ = Math.abs(q - roundedQ)\n    const diffR = Math.abs(r - roundedR)\n    const diffS = Math.abs(s - roundedS)\n\n    if (diffQ > diffR && diffQ > diffS) {\n      roundedQ = -roundedR - roundedS\n    } else if (diffR > diffS) {\n      roundedR = -roundedQ - roundedS\n    } else {\n      roundedS = -roundedQ - roundedR\n    }\n\n    return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n  }\n}\n\nexport function lerpFactory({ Hex }) {\n  /**\n   * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n   * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n   *\n   * @memberof Hex#\n   *\n   * @param   {hex} hex   The other hex (cannot be a {@link point}).\n   * @param   {number} t  A \"parameter\" between 0 and 1.\n   *\n   * @returns {hex}       A new hex (likely with floating point coordinates).\n   *                      Any custom properties are copied.\n   */\n  return function lerp(hex, t) {\n    const q = this.q * (1 - t) + hex.q * t\n    const r = this.r * (1 - t) + hex.r * t\n    return Hex({ ...this, q, r, s: -q - r })\n  }\n}\n\nexport function nudgeFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n   *                  Useful for interpolating in a consistent direction.\n   */\n  return function nudge() {\n    const { q, r, s } = EPSILON\n    return Hex({ ...this, q: this.q + q, r: this.r + r, s: this.s + s })\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n  return `${this.x},${this.y}`\n}\n","import { isArray, isNumber, isObject } from 'axis.js'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport const staticMethods = {\n  thirdCoordinate: statics.thirdCoordinate,\n}\n\nexport default function extendHexFactory({ ensureXY, normalizeRadiuses, Point }) {\n  /**\n   * @function extendHex\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create custom hexes by extending the default Hex prototype.\n   *\n   * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n   * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n   *\n   * @todo validate orientation, origin\n   * @todo warn when properties are overriden\n   *\n   * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n   *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n   *\n   * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({\n   *     size: 50,\n   *     orientation: 'flat',\n   *     customProperty: `I'm custom `,\n   *     customMethod() {\n   *         return `${this.customProperty} and called from a custom method `\n   *     }\n   * })\n   * const hex = Hex(5, -1)\n   *\n   * hex.coordinates()    // { x: 5, y: -1 }\n   * // size is normalized to an object containing an x radius and y radius:\n   * hex.size             // { xRadius: 50, yRadius: 50 }\n   * hex.customProperty   // I'm custom \n   * hex.customMethod()   // I'm custom  and called from a custom method \n   *\n   * // every hex created with Hex() shares these properties:\n   * const hex2 = Hex(3, 0)\n   * hex2.size            // { xRadius: 50, yRadius: 50 }\n   * hex2.customProperty  // I'm custom \n   *\n   * // to set properties on individual hexes, pass them to Hex():\n   * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake ` })\n   * hex3.instanceProperty    // I'm a unique snowflake \n   */\n  return function extendHex(prototype = {}) {\n    const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n    const defaultPrototype = {\n      /**\n       * Used internally for type checking\n       *\n       * @memberof Hex#\n       * @private\n       */\n      __isHoneycombHex: true,\n      /**\n       * Either  pointy or  flat. Defaults to `pointy`.\n       *\n       * @memberof Hex#\n       * @type {string}\n       * @default 'pointy'\n       */\n      orientation: 'pointy',\n      /**\n       * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n       * Can be anything the {@link Honeycomb.Point} factory accepts.\n       * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n       *\n       * @memberof Hex#\n       * @type {point}\n       * @default 0\n       */\n      origin: 0,\n      /**\n       * A hex's size that can be set as:\n       * * an object with `width` and `height`, representing the total width and height of the hex\n       * * an object with `xRadius` and `yRadius`. This can be visualized as if the hex was enclosed in an ellipse.\n       *   `xRadius` would be the distance from the center to the left or right of the ellipse (semi-major axis) and\n       *   `yRadius` would be the distance from the center to the top or bottom of the ellipse (semi-minor axis).\n       * * a number, represening the length of each side and the distance from the center to any corner of the hex\n       *   (which are the same in regular hexagons).\n       *\n       * ![Different ways to set size](docs/hex-sizes.png)\n       *\n       * When setting size with a number the hex will be regular. When setting size with an object it's possible to\n       * \"stretch\" a hex; having a (very) different width and height.\n       *\n       * Defaults to `{ xRadius: 1, yRadius: 1 }`.\n       *\n       * @memberof Hex#\n       * @type {{width: number, height: number}|{xRadius: number, yRadius: number}|number}\n       * @default { xRadius: 1, yRadius: 1 }\n       */\n      size: { xRadius: 1, yRadius: 1 },\n      /**\n       * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n       * Defaults to `-1` (odd offset).\n       * See {@link OFFSET} for details.\n       * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n       *\n       * @memberof Hex#\n       * @type {number}\n       * @default -1\n       * @see OFFSET\n       */\n      offset: -1,\n      /**\n       * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get q() {\n        return this.cartesianToCube(this).q\n      },\n      /**\n       * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get r() {\n        return this.cartesianToCube(this).r\n      },\n      /**\n       * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get s() {\n        return this.cartesianToCube(this).s\n      },\n\n      // methods:\n      add: methods.addFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#coordinates}.\n       * @memberof Hex#\n       * @instance\n       */\n      cartesian: methods.coordinates,\n      cartesianToCube,\n      center: methods.centerFactory({ Point }),\n      coordinates: methods.coordinates,\n      corners: methods.cornersFactory({ Point }),\n      cube: methods.cube,\n      cubeToCartesian: methods.cubeToCartesian,\n      distance: methods.distance,\n      equals: methods.equalsFactory({ Point }),\n      fromPoint: methods.fromPointFactory({ Point, Hex }),\n      height: methods.height,\n      isFlat: methods.isFlat,\n      isPointy: methods.isPointy,\n      lerp: methods.lerpFactory({ Hex }),\n      nudge: methods.nudgeFactory({ Hex }),\n      round: methods.roundFactory({ Hex }),\n      set: methods.setFactory({ Hex }),\n      subtract: methods.subtractFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#cubeToCartesian}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCartesian: methods.cubeToCartesian,\n      /**\n       * Alias for {@link Hex#cartesianToCube}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCube: cartesianToCube,\n      toPoint: methods.toPointFactory({ Point }),\n      toString: methods.toString,\n      width: methods.width,\n    }\n    const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n    finalPrototype.size = normalizeRadiuses(finalPrototype.size, finalPrototype.isPointy())\n    // ensure origin is a point\n    finalPrototype.origin = Point(finalPrototype.origin)\n\n    // the toJSON method is added here, because only here it has (easy) access to the prototype\n    Object.assign(Hex, staticMethods, { toJSON: () => prototype })\n\n    /**\n     * @function Hex\n     *\n     * @description\n     * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n     *\n     * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n     *\n     * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n     *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n     *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n     *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n     * @param {number} [xOrProps.x=]                    The x coordinate.\n     * @param {number} [xOrProps.y=]                    The y coordinate.\n     * @param {number} [y=]                             The y coordinate.\n     * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n     *\n     * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * // passing numbers:\n     * Hex()                        // { x: 0, y: 0 }\n     * Hex(1)                       // { x: 1, y: 1 }\n     * Hex(1, 2)                    // { x: 1, y: 2 }\n     *\n     * // passing an object with cartesian coordinates:\n     * Hex({})                      // { x: 0, y: 0 }\n     * Hex({ x: 1 })                // { x: 1, y: 1 }\n     * Hex({ y: 2 })                // { x: 2, y: 2 }\n     * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n     *\n     * // passing an object with cube coordinates:\n     * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n     * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n     *\n     * // passing an array:\n     * Hex([])                      // { x: 0, y: 0 }\n     * Hex([1])                     // { x: 1, y: 1 }\n     * Hex([1, 2])                  // { x: 1, y: 2 }\n     *\n     * // custom properties:\n     * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n     * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n     *\n     * // cloning a hex:\n     * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n     * const clone = Hex(someHex)   // { x: 4, y: -2 }\n     * someHex === clone            // false\n     */\n    function Hex(xOrProps, y, customProps = {}) {\n      let x\n\n      if (isObject(xOrProps)) {\n        let { q, r, s, ...rest } = xOrProps\n\n        if (isNumber(q) || isNumber(r) || isNumber(s)) {\n          const sum = q + r + s\n          // when any coordinate is undefined, sum will be NaN\n          // deal with floating point errors by allowing a maximum precision of 1e-12\n          if (Number.isNaN(sum) || sum > 1e-12) {\n            throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n          }\n\n          ;({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n        } else {\n          ;({ x, y } = xOrProps)\n        }\n\n        customProps = rest\n      } else if (isArray(xOrProps)) {\n        ;[x, y] = xOrProps\n        // ignore all arguments except xOrProps\n        customProps = {}\n      } else {\n        x = xOrProps\n      }\n\n      /**\n       * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n       *\n       * @typedef {Object} hex\n       * @property {number} x Cartesian x coordinate.\n       * @property {number} y Cartesian y coordinate.\n       */\n      return Object.assign(\n        // the prototype has to be attached here, else Grid's shape methods break \n        Object.create(finalPrototype),\n        Object.assign(customProps, ensureXY(x, y)),\n      )\n    }\n\n    return Hex\n  }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n  return -firstCoordinate - secondCoordinate\n}\n","import defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport extendHexFactory from './hex'\nimport PointFactory from './point'\nimport { ensureXY, normalizeRadiuses } from './utils'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, normalizeRadiuses, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport { extendHex, defineGrid, Point }\n","import { isArray, isNumber } from 'axis.js'\nimport { compassToNumberDirection, signedModulo } from '../utils'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n  const { isValidHex } = Grid\n\n  /**\n   * @function defineGrid\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n   *\n   * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n   *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n   *\n   * @returns {Grid}                          A Grid factory.\n   *\n   * @example\n   * // create a Grid factory that uses the default Hex Factory:\n   * const Grid = Honeycomb.defineGrid()\n   * const hex = Grid.Hex()\n   * hex.size         // { xRadius: 1, yRadius: 1 }\n   *\n   * // create your own Hex factory\n   * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '' })\n   * // and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n   * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n   * const customHex = CustomGrid.Hex()\n   * customHex.size   // { xRadius: 10, yRadius: 10 }\n   * customHex.custom // \n   */\n  return function defineGrid(Hex = extendHex()) {\n    // static properties\n    Object.assign(GridFactory, {\n      /**\n       * The {@link Hex} factory the Grid factory was created with.\n       * @memberof Grid\n       * @static\n       * @function\n       */\n      // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n      // it could cause this:\n      // function methodThatBindsThis() {\n      //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n      // }\n      // which is caused by the following line:\n      Hex,\n\n      // methods\n      /**\n       * @memberof Grid\n       * @static\n       * @method\n       *\n       * @param {*} value     Any value.\n       * @returns {boolean}   Whether the passed value is a valid hex.\n       */\n      isValidHex,\n      pointToHex: statics.pointToHexFactory({ Point, Hex }),\n      parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n      triangle: statics.triangleFactory({ Grid, Hex }),\n      hexagon: statics.hexagonFactory({ Grid, Hex }),\n      rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }),\n      ring: statics.ringFactory({ Grid, Hex }),\n      spiral: statics.spiralFactory({ Grid, Hex }),\n    })\n\n    // prototype properties\n    Object.assign(Grid.prototype, {\n      // methods\n      get: methods.get,\n      hexesBetween: methods.hexesBetween,\n      hexesInRange: methods.hexesInRangeFactory({ isValidHex }),\n      neighborsOf: methods.neighborsOfFactory({\n        isValidHex,\n        signedModulo,\n        compassToNumberDirection,\n      }),\n      pointHeight: methods.pointHeight,\n      pointWidth: methods.pointWidth,\n      set: methods.setFactory({ isValidHex }),\n    })\n\n    /**\n     * @function Grid\n     *\n     * @description\n     * A function to create hex {@link grid}s and perform various operations on them.\n     *\n     * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n     * It can also be called with 1 or more points/hexes or an array of points/hexes to create a {@link grid} instance.\n     *\n     * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n     *\n     * @param {...point} [points] An array of points/hexes or separate arguments that are points/hexes.\n     * @returns {grid}            A grid instance containing only valid hexes.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * // the Hex factory used by the Grid to produce hexes is available as a property\n     * const Hex = Grid.Hex\n     *\n     * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // it also accepts points\n     * Grid({ x: 3, y: -1 }, [2, 0])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([{ x: 3, y: -1 }, [2, 0]])  // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // clone a grid:\n     * const grid = Grid(Hex(), Hex(1), Hex(2))\n     * const clonedGrid = Grid(grid)      // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n     * grid === clonedGrid                // false\n     */\n    function GridFactory(...points) {\n      points = points.filter(Boolean)\n\n      if (isArray(points[0]) && (points[0].length === 0 || points[0].some((point) => !isNumber(point)))) {\n        points = points[0]\n      }\n\n      /**\n       * @typedef {Object} grid\n       * @extends Array\n       *\n       * @property {number} length    Amount of hexes in the grid.\n       */\n      return new Grid(...points.map((point) => Hex(point)))\n    }\n\n    return GridFactory\n  }\n}\n"]},"metadata":{},"sourceType":"module"}