{"version":3,"sources":["Hexgrid.js","App.js","reportWebVitals.js","index.js"],"names":["openmoji","require","numEmojis","maxHorizontal","maxVertical","Math","ceil","center","round","lenHistory","defaultEmojis","index","push","openmojis","hexcode","tempmojis","cat1Index","cat2Index","cat3Index","cat7Index","cat8Index","cat9Index","cat10Index","cat11Index","cat12Index","imageURLs","Array","Hexgrid","useState","emojiHistory","setEmojiHistory","iniTileObj","newTileObject","emojiTiles","setEmojiTiles","tmpTileObj","getTileImage","tileIndex","image","isArray","_emojis","selectedHexcode","hexcodes","blendedHexcodes","i","length","undefined","forEach","indexOf","tileObj","map","colour","includes","getTileColour","img","key","onClick","e","handleClick","fill","styles","normal","hover","active","getRandomBlendHexcodes","Promise","resolve","reject","obj","fetch","toString","then","res","json","data","JSON","parse","getMarkovHexcodes","getMarkovBlendHexcodes","limit","updateEmojiHistory","num","newEmojis","shift","getBlendHexcode","hexcode1","hexcode2","id","console","log","imgURL","saveAs","all","values","newTileObj","catch","error","message","window","addEventListener","event","tileSideLengths","tileGap","tileBorderRadii","tileTextStyles","fontFamily","fontSize","tiles","onLoad","App","className","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.165f5039.chunk.js","sourcesContent":["import { TiledHexagons } from 'tiled-hexagons'\nimport { useState, useEffect } from 'react'\nimport React, { Component } from 'react';\nimport { saveAs } from 'file-saver';\n\nconst openmoji = require('openmoji');\nconst fs = require('fs');\n\nconst numEmojis = 259;\nconst maxHorizontal = 19;//111\nconst maxVertical = Math.ceil(numEmojis / maxHorizontal);\n\nconst center = Math.round((maxHorizontal * (maxVertical / 4)) + ((maxHorizontal - 1) * (maxVertical / 4))) - Math.round((maxHorizontal) / 2);//Math.ceil(numEmojis/2)-3;\nconst lenHistory = Math.ceil(maxHorizontal / 2) - 1;\nconst lenRandom = lenHistory;\nconst defaultEmojis = [];\n\nfor (let index = 0; index < numEmojis; index++) {\n  defaultEmojis.push(openmoji.openmojis[3073].hexcode);\n}\nvar tempmojis = [[]];\nfor (let index = 0; index < numEmojis; index++) {\n  tempmojis[0].push(openmoji.openmojis[3073].hexcode)\n }\n \nconst cat1Index = [0, 1, 2, 3, 4, 5,\n  19, 20, 21, 22, 23, 24,\n  37, 38, 39, 40, 41, 42, 43,\n  56, 57, 58, 59, 60, 61, 62,\n  74, 75, 76, 77, 78, 79, 80, 81,\n  93, 94, 95, 96, 97, 98, 99]; //100\n\nconst cat2Index = [7, 8, 9, 10, 11,\n  26, 27, 28, 29,\n  45, 46, 47,\n  64, 65,\n  83];\n\nconst cat3Index = [13, 14, 15, 16, 17, 18,\n                  31, 32, 33, 34, 35, 36,\n                  49, 50, 51, 52, 53, 54, 55,\n                  67, 68, 69, 70, 71, 72, 73,\n                  85, 86, 87, 88, 89, 90, 91, 92,\n                  103, 104, 105, 106, 107, 108, 109, 110];\n\nconst cat4Index = []; //137\nconst cat5Index = [];\nconst cat6Index = [];\n\nconst cat7Index = [121, 122, 123, 124, 125, 126, 127, 128, 129]; //Line heading right from center\nconst cat8Index = [139, 158, 177, 196, 215, 234, 253]; //Line heading right-down from center\nconst cat9Index = [138, 156, 174, 192, 210, 228, 246]; //Line heading left-down from center\nconst cat10Index = [111, 112, 113, 114, 115, 116, 117, 118, 119]; //Line heading left from center\nconst cat11Index = [6, 25, 44, 63, 82, 101]; //Line heading left-up from center\nconst cat12Index = [12, 30, 48, 66, 84, 102]; //Line heading right-up from center\n\nlet imageURLs = new Array(numEmojis);\n\nconst Hexgrid = () => {\n  const [emojiHistory, setEmojiHistory] = useState([]);\n  var iniTileObj = newTileObject([defaultEmojis]);\n  const [emojiTiles, setEmojiTiles] = useState(iniTileObj); //\n  const tmpTileObj = newTileObject(tempmojis, openmoji.openmojis[3073].hexcode);\n\n  function getTileColour(tileIndex) {\n    let colour = 'white';\n    if(cat7Index.includes(tileIndex) || cat8Index.includes(tileIndex) || cat9Index.includes(tileIndex) || cat10Index.includes(tileIndex) || cat11Index.includes(tileIndex) || cat12Index.includes(tileIndex)){\n      colour = 'white'; //white\n    }\n    else{\n      colour = '#dbf7fd';//'blue;\n    }\n    // if (tileIndex <= (center - 1) && tileIndex >= (center - lenHistory)) { //If tile is part of emoji history\n    //   colour = '#dbf7fd';//'#d4d4d4';\n    // }\n    if (tileIndex === center) { //If active emoji tile\n      colour = '#a4eefc';\n    }\n    return colour;\n  }\n\n  function getTileImage(tileIndex, hexcode) {\n    let image = ``;\n\n    if (Array.isArray(hexcode)) { //Then hexcode is a blend\n      //image = `http://localhost:9000/blends/1F9431F0CF.png`;\n      // fetch(\"http://localhost:9000/blendemojis/\" + hexcode[0] + \"/\" + hexcode[1])\n      //   .then(res => res.json())\n      //   .then(data => { image = \"http://localhost:9000/blends/\" + data.url;})\n      //   .then(() => { return image })\n      //return 'http://localhost:9000/blends/1F9431F0CF.png';\n      return image\n    }\n    else { //it is a single emoji character\n      image = \"/images/\" + hexcode + \".png\";\n      return image;\n    }\n  }\n\n  function newTileObject(_emojis, selectedHexcode) {\n    let hexcodes = _emojis[0];\n    let blendedHexcodes = _emojis[1];\n    for (let i = 0; i < hexcodes.length; i++) {\n      imageURLs[i] = getTileImage(i, hexcodes[i]);\n    }\n\n    /*\n    Substitute blendedHexcodes into hexcodes where appropriate\n    */\n    if (blendedHexcodes !== undefined && blendedHexcodes !== null && selectedHexcode !== undefined) {\n      cat1Index.forEach(index => {\n        hexcodes[index] = blendedHexcodes[cat1Index.indexOf(index)];\n        //console.log(hexcodes[index]);\n      });\n    }\n\n      /*\n      Insert emoji history into active tiles\n      */\n      if (emojiHistory.length >= 1) {\n        for (let i = 0; i < emojiHistory.length; i++) {\n          if (center - i - 1 >= (center - lenHistory)) {\n            hexcodes[center - i -1] = emojiHistory[emojiHistory.length - 2 - i];\n          }\n        }\n      }\n\n      // if (emojiHistory.length >= 1) {\n      //   values[0][center] = emojiHistory[emojiHistory.length-1];\n      //   for (let i = 0; i < emojiHistory.length-1; i++) {\n      //     if (center - i -1> 49) {\n      //       values[0][center - i - 2] = emojiHistory[emojiHistory.length - 1 - i];\n      //     }\n      //   }\n      // }\n\n    /*\n    Map hexcodes to tiles \n    */\n    const tileObj = hexcodes.map((hexcode, index) => {\n      /*  \n      Assign tile colour based on position in grid\n      */\n      let colour = getTileColour(index);\n\n      /*  \n      Assign tile image based on position in grid\n      */\n      //let image = `/images/1F4EF.svg`;\n      //image = imageURLs[index];//getTileImage(index, hexcode); //get image then return tile\n      if (Array.isArray(hexcode)) { //Then hexcode is a blend\n        //image = `http://localhost:9000/blends/1F9431F0CF.png`;\n        // fetch(\"http://localhost:9000/blendemojis/\" + hexcode[0] + \"/\" + \"1F0CF\")\n        //   .then(res => res.json())\n        //   .then(data => { imageURLs[index] = \"http://localhost:9000/blends/\" + data.url })\n        //return 'http://localhost:9000/blends/1F9431F0CF.png';\n        //return image\n        imageURLs[index] = \"/blends/\" + hexcode[0] + hexcode[1] + '.png';\n      }\n      else { //it is a single emoji character\n        imageURLs[index] = \"/images/\" + hexcode + \".png\";\n      }\n      return {\n        img: imageURLs[index],\n        key: index,\n        onClick: (e) => handleClick(index, hexcode, e),\n        fill: '',\n        styles: {\n          normal: {\n            fill: colour\n          },\n          hover: {\n            fill: '#6cc7da'\n          },\n          active: {\n            fill: '#779df1'\n          }\n        }\n      }\n    })\n\n    return tileObj;\n  }\n\n  /*  \n  Get random emojis for every tile\n  */\n  function getRandomHexcodes() {\n    return new Promise((resolve, reject) => {\n      var obj;\n      fetch(\"/api/randomhexcodes?limit=\" + numEmojis.toString())\n        .then(res => res.json())\n        .then(data => obj = JSON.parse(data))\n        .then(() => { resolve(obj); })\n    })\n  }\n\n  /*  \n  Get random blends\n  */\n  function getRandomBlendHexcodes(hexcode) {\n    return new Promise((resolve, reject) => {\n      var obj;\n      fetch(\"/api/randomblendhexcodes/\" + hexcode + \"?limit=\" + cat1Index.length.toString())\n        .then(res => res.json())\n        .then(data => obj = JSON.parse(data))\n        .then(() => { resolve(obj); })\n    })\n  }\n\n  /*  \n  Get markov emojis\n  */\n  function getMarkovHexcodes(hexcode) {\n    return new Promise((resolve, reject) => {\n      var obj;\n      fetch(\"/api/markovhexcodes/\" + hexcode + \"?limit=\" + cat7Index.length.toString())\n        .then(res => res.json())\n        .then(data => obj = JSON.parse(data))\n        .then(() => { resolve(obj); })\n    })\n  }\n\n    /*  \n  Get markov blends\n  */\n  function getMarkovBlendHexcodes(hexcode, limit) {\n    return new Promise((resolve, reject) => {\n      var obj;\n      fetch(\"/api/markovblendhexcodes/\" + hexcode + \"?limit=\" + limit.toString())\n        .then(res => res.json())\n        .then(data => obj = JSON.parse(data))\n        .then(() => { resolve(obj); })\n    })\n  }\n\n  /*\n  Update emoji history and remove the oldest entry if length exceeds max.\n  */\n  function updateEmojiHistory(hexcode, num) {\n    let newEmojis = emojiHistory;\n    for (let i = 0; i < num; i++) {\n      newEmojis.push(hexcode);\n      if (newEmojis.length > lenHistory+1) {\n        newEmojis.shift();\n      }\n    }\n    setEmojiHistory(newEmojis);\n  }\n\n  function getBlendHexcode(hexcode1, hexcode2) {\n    return new Promise((resolve, reject) => {\n      var obj;\n      fetch(\"/api/blendemojis/\" + hexcode1 + \"/\" + hexcode2)\n        .then(res => res.json())\n        .then(() => { obj = [hexcode1, hexcode2]; })\n        .then(() => { resolve(obj); })\n    })\n  }\n\n  const handleClick = (id, hexcode, e) => {\n    console.log(hexcode + ' was clicked. ID is ' + id);\n\n    if (id === center) {\n      var imgURL = '';\n    \n      if (Array.isArray(hexcode)) { //Then hexcode is a blend\n        imgURL = \"/blends/\" + hexcode[0] + hexcode[1] + '.png';\n      }\n      else { //it is a single emoji character\n        imgURL = \"/images/\" + hexcode + \".png\";\n      }\n  \n      saveAs(imgURL, 'blend.png');\n    }\n    else if(hexcode !== '1F504'){\n      updateEmojiHistory(hexcode, 1); //Add clicked emoji to emoji history\n\n      /*\n      TODO: Replace all emoji with 'loading' emoji with no click handler\n      */\n\n      setEmojiTiles(tmpTileObj);\n\n      // var tmpTileObj;\n      // const tilePromise = new Promise((resolve, reject) => {\n      //   tmpTileObj = newTileObject(tempmojis, hexcode);\n      //   resolve();\n      // });\n      // tilePromise\n      //   .then(() => { setEmojiTiles(tmpTileObj); }).catch(error => {\n      //     console.log(\"Something went wrong with the tilePromise.\")\n      //     console.error(error.message)\n      //   });\n\n      //TODO: This is a quick fix, find a way to send both hexcodes and still get blends:\n      if(Array.isArray(hexcode)){ //Then hexcode is a blend\n        hexcode = hexcode[1];\n      }\n  \n      //Get hexcodes for new tiles, then assign them to tiles:\n      Promise.all([getRandomHexcodes(), getRandomBlendHexcodes(hexcode), getMarkovHexcodes(hexcode), getBlendHexcode(hexcode, emojiHistory[emojiHistory.length - 2]), getBlendHexcode(emojiHistory[emojiHistory.length - 2], hexcode), getMarkovBlendHexcodes(hexcode, cat2Index.length),getMarkovBlendHexcodes(hexcode, cat3Index.length)]).then((values) => {\n        //Substitute blendedHexcodes into hexcodes where appropriate:\n        if (values[1] !== undefined && values[1] !== null && values[2] !== null && hexcode !== undefined) {\n          cat1Index.forEach(index => {\n            values[0][index] = values[1][cat1Index.indexOf(index)];\n          });\n          cat7Index.forEach(index => {\n            values[0][index] = values[2][cat7Index.indexOf(index)];\n          });\n          cat2Index.forEach(index => {\n            values[0][index] = values[5][cat2Index.indexOf(index)];\n          });\n          cat3Index.forEach(index => {\n            values[0][index] = values[6][cat3Index.indexOf(index)];\n          });\n\n        }\n\n        values[0][100] = values[3]; //Make this one a blend between current and most recent history\n        values[0][137] = values[4]; //Make this one a blend between current and most recent history\n  \n        //Insert emoji history into active tiles:\n        if (emojiHistory.length >= 1) {\n          values[0][center] = emojiHistory[emojiHistory.length-1];\n          for (let i = 0; i < emojiHistory.length; i++) {\n            if (center - i - 1 >= (center - lenHistory)) {\n              values[0][center - i - 1] = emojiHistory[emojiHistory.length - 1 - i];\n            }\n          }\n        }\n\n        var newTileObj;\n        const tilePromise = new Promise((resolve, reject) => {\n          newTileObj = newTileObject(values, hexcode);\n          resolve();\n        });\n        tilePromise\n          .then(() => { setEmojiTiles(newTileObj);           console.log(values);\n          }).catch(error => {\n            console.log(\"Something went wrong with the tilePromise.\")\n            console.error(error.message)\n          });\n  \n        //newTileObj = newTileObject(values, hexcode); //gen tiles then return them\n      }).catch(error => {\n        console.error(error.message)\n      });\n    }\n  }\n\n  /*\n  Display the initial emoji options.\n  This is occuring twice according to the API terminal\n  */\n  window.addEventListener('DOMContentLoaded', (event) => {\n    /*\n      Fill the emoji history with placeholders\n    */\n    updateEmojiHistory(openmoji.openmojis[3073].hexcode, lenHistory+1 );\n    \n    /*\n      TODO: Replace this with a call to the getrandoms function\n    */\n    var obj;\n    fetch(\"/api/randomhexcodes?limit=\" + numEmojis.toString())\n      .then(res => res.json())\n      .then(data => obj = JSON.parse(data))\n      .then(() => iniTileObj = newTileObject([obj, []]))\n      .then(() => setEmojiTiles(iniTileObj))\n      .catch(error => {\n        console.log(\"Something went wrong with the randomhexcodes fetch request.\")\n        console.error(error.message)\n      })\n  });\n\n  return (\n    <>\n      <TiledHexagons\n        tileSideLengths={60}\n        tileGap={4}\n        tileBorderRadii={9}\n        maxHorizontal={maxHorizontal}\n        tileTextStyles={{\n          fontFamily: 'Source Sans Pro',\n          fontSize: '68px',\n        }}\n        tiles={emojiTiles}\n        onLoad={() => handleClick()}\n      />\n    </>\n  );\n}\n\nexport default Hexgrid;","import React, { Component } from \"react\";\n// Importing style sheet (TODO: remove this later)\nimport './App.css';\n\n// Importing pages and components\nimport Home from \"./Home\";\nimport Navbar from \"./Navbar\";\nimport Hexgrid from \"./Hexgrid\";\n\n\nclass App extends Component {\n  render(){\n    return (    \n      <div className=\"App\">\n        {/* Navigation Bar Component*/}\n        {/*<Navbar /> */} \n        <div className=\"content\">\n          <Hexgrid />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}